module dmud.domain;

import std.uni, std.string;
import dmud.log;
import dmud.telnet_socket;

class MudObj {
	/// Internal ID. This should be a human-readable string.
	/// Recommended format should be path-style, eg "/core/mobs/farmers/turnip_farmer".
	string id;

	/// Autogenerated ID number.
	int idNum;

	/// User-visible name for the object. What they see when they look at it.
	/// Example: "The Reverend", "bodging knife", "The Inn at the Market"
	string name;

	/// What the player sees when looking at this thing.
	string description;

	/// Other names by which this object can be referred to.
	string[] aliases;

	/// The current command generation of this mud object.
	/// For objects that can act (players, mobs, scripted items), this is the cancellation mechanism
	/// for scheduled actions.
	int generation;

	override string toString() { return name; }

	string the() {
		if (isUpper(name[0])) {
			return name;
		}
		if (name.startsWith("the")) {
			return name;
		}
		return "the " ~ name;
	}

	string a() {
		if (isUpper(name[0])) {
			return name;
		}
		if (name.startsWith("the")) {
			return name;
		}
		return "a " ~ name;
	}

	bool identifiedBy(string phrase) {
		if (name == phrase) return true;
		foreach (n; aliases) {
			if (n == phrase) return true;
		}
		return false;
	}

	string lookAt() {
		return description;
	}
}

class Item : MudObj {
	/// An item is always in something else. A room, a mob's inventory, or a
	/// container. This is what it's in.
	MudObj containing;
}

struct Exit {
	Room target;
	string targetName;
	string name;
	string[] aliases;
	bool identifiedBy(string str) {
		if (name.toLower == str.toLower) {
			return true;
		}
		logger.infof("[%s] != [%s]", name, str);
		foreach (a; aliases) {
			if (a.toLower == str.toLower) {
				return true;
			}
			logger.infof("[%s] != [%s]", a, str);
		}
		return false;
	}
}

class Room : MudObj {
	Mob[] mobs;
	Item[] items;
	Exit[] exits;
}

class Behavior {

}

// TODO: some sort of MobRecipe so I can have variants.
// Some simple text replacement in the description and name, some attribute variation, etc.
class Mob : MudObj {
	Room room;
	Item[] inventory;
	Behavior behavior;
	TelnetSocket telnet;
	
	void write(string value) {
		if (telnet) {
			telnet.write(value);
		}
	}
	
	void writeln(string value) {
		if (telnet) {
			telnet.writeln(value);
		}
	}
}

/* TODO what kind of separation do I want between the base definition of the world and its
 * current state?
 *
 * I could have the base def essentially be a serialized version of a state -- that makes it pretty
 * easy to start up but means little flexibility.
 *
 * I could have template versions of everything. In order to load a world, I instantiate a series of
 * RoomTemplates, each of which involves instantiating MobTemplates and so on.
 *
 * I could have rooms be fixed. Some specify which mobs should be in them; some are parts of zones
 * that specify what types of mobs can spawn there at random. Then, on load and randomly after that,
 * we spawn more mobs. Ensure that there's at least X mobs per room and no more than Y, sort of
 * thing, in a given zone.
 */


/** A zone is a group of rooms with similar treatment.
 * For now, "similar treatment" pretty much means mob spawns.
 */
class Zone : MudObj {
	/// Rooms belonging to this zone.
	Room[] rooms;

	/// The mobs that randomly spawn in this zone.
	// TODO: what about mob groups? Like a banker and a bodyguard?
	Mob[] mobs;
}


class World {
	static World current;
	Mob[string] mobs;
	Zone[string] zones;
	Item[string] items;
	Room startingRoom;
}
